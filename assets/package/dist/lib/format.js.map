{"version":3,"sources":["../../src/lib/format.js"],"names":["fence","formatDataTable","formatDocString","formatScenario","StripAnsiTransform","Transform","_transform","chunk","encoding","cb","toString","colorFns","marker","normal","inverse","bold","warn","yellow","italic","header","obj","body","colors","depth","arg","rows","map","row","cells","cell","value","replace","table","Table","chars","bottom","left","mid","middle","right","top","style","border","push","content","gherkinDocument","pickle","cyan","blue","magenta","stepLineToKeywordMap","str","name","pickleStep","steps","keyword","text","stringifyArgument","arguments"],"mappings":";;;;;;QAuBgBA,K,GAAAA,K;QAgBAC,e,GAAAA,e;QAoCAC,e,GAAAA,e;QAOAC,c,GAAAA,c;;AAlFhB;;AACA;;;;AACA;;AACA;;AACA;;;;AACA;;;;AACA;;AACA;;AACA;;;;;;AAEO,MAAMC,kBAAN,SAAiCC,iBAAjC,CAA2C;AAChDC,aAAWC,KAAX,EAAkBC,QAAlB,EAA4BC,EAA5B,EAAgC;AAC9BA,OAAG,IAAH,EAAS,yBAAUF,MAAMG,QAAN,EAAV,CAAT;AACD;AAH+C;;QAArCN,kB,GAAAA,kB;AAMb,MAAMO,WAAW,6BAAY,IAAZ,CAAjB;AACA,MAAMC,SAAS;AACbC,UAAQF,SAASG,OAAT,CAAiBC,IADZ;AAEbC,QAAML,SAASM,MAAT,CAAgBH,OAAhB,CAAwBC,IAFjB;AAGbG,UAAQP,SAASO;AAHJ,CAAf;;AAMO,SAASlB,KAAT,CAAemB,MAAf,EAAuBC,GAAvB,EAA4B;AACjC,MAAI,CAACA,GAAD,IAAQ,oBAAQA,GAAR,CAAZ,EAA0B;AACxB,WAAQ;EACVR,OAAOI,IAAP,CAAa,MAAKJ,OAAOM,MAAP,CAAe,MAAKC,MAAO,WAA3B,CAAuC,KAAzD,CAA+D;CAD7D;AAGD,GAJD,MAIO;AACL,UAAME,OAAO,OAAOD,GAAP,KAAe,QAAf,GAA0BA,GAA1B,GAAgC,mBAAQA,GAAR,EAAa,EAAEE,QAAQ,IAAV,EAAgBC,OAAO,IAAvB,EAAb,CAA7C;;AAEA,WAAQ;EACVX,OAAOC,MAAP,CAAe,eAAcM,MAAO,QAApC,CAA6C;EAC7CE,IAAK;EACLT,OAAOC,MAAP,CAAe,cAAaM,MAAO,SAAnC,CAA6C;CAH3C;AAKD;AACF;;AAEM,SAASlB,eAAT,CAAyBuB,GAAzB,EAA8B;AACnC,QAAMC,OAAOD,IAAIC,IAAJ,CACVC,GADU,CACNC,OAAOA,IAAIC,KAAJ,CACTF,GADS,CACLG,QAAQA,KAAKC,KAAL,CACVC,OADU,CACF,KADE,EACK,MADL,EAEVA,OAFU,CAEF,KAFE,EAEK,KAFL,CADH,CADD,CAAb;;AAMA,QAAMC,QAAQ,IAAIC,kBAAJ,CAAU;AACtBC,WAAO;AACLC,cAAQ,EADH;AAEL,qBAAe,EAFV;AAGL,oBAAc,EAHT;AAIL,sBAAgB,EAJX;AAKLC,YAAM,GALD;AAML,kBAAY,EANP;AAOLC,WAAK,EAPA;AAQL,iBAAW,EARN;AASLC,cAAQ,GATH;AAULC,aAAO,GAVF;AAWL,mBAAa,EAXR;AAYLC,WAAK,EAZA;AAaL,kBAAY,EAbP;AAcL,iBAAW,EAdN;AAeL,mBAAa;AAfR,KADe;AAkBtBC,WAAO;AACLC,cAAQ,EADH;AAEL,sBAAgB,CAFX;AAGL,uBAAiB;AAHZ;AAlBe,GAAV,CAAd;;AAyBAV,QAAMW,IAAN,CAAW,GAAGlB,IAAd;AACA,SAAQ,GAAEO,MAAMtB,QAAN,EAAiB,IAA3B;AACD;;AAEM,SAASR,eAAT,CAAyBsB,GAAzB,EAA8B;AACnC,SAAQ;EACRA,IAAIoB,OAAQ;;CADZ;AAID;;AAEM,SAASzC,cAAT,CAAwB,EAAE0C,eAAF,EAAmBC,MAAnB,EAAxB,EAAqD;AAC1D,QAAM,EAAE/B,IAAF,EAAQgC,IAAR,EAAcC,IAAd,EAAoBC,OAApB,KAAgCtC,QAAtC;;AAEA,QAAMuC,uBAAuB,sDAAwBL,eAAxB,CAA7B;;AAEA,MAAIM,MAAO,GAAEJ,KAAKhC,KAAK,WAAL,CAAL,CAAwB,IAAG+B,OAAOM,IAAK,IAApD;;AAEA,OAAK,MAAMC,UAAX,IAAyBP,OAAOQ,KAAhC,EAAuC;AACrC,UAAMC,UAAU,mCAAe,EAAEF,UAAF,EAAcH,oBAAd,EAAf,CAAhB;;AAEAC,WAAQ,KAAIF,QAAQlC,KAAKwC,OAAL,CAAR,CAAuB,GAAEF,WAAWG,IAAK,IAArD;;AAEA,UAAMhC,MAAMiC,kBAAkBJ,WAAWK,SAA7B,CAAZ;AACA,QAAIlC,GAAJ,EACE2B,OAAO,4BAAOH,KAAKxB,GAAL,CAAP,EAAkB,CAAlB,CAAP;AACH;;AAED,SAAO2B,GAAP;;AAEA,WAASM,iBAAT,CAA2B,CAAEjC,GAAF,CAA3B,EAAoC;AAClC,QAAIA,GAAJ,EAAS;AACP,UAAI,UAAUA,GAAd,EAAmB,OAAOvB,gBAAgBuB,GAAhB,CAAP;AACnB,UAAI,aAAaA,GAAjB,EAAsB,OAAOtB,gBAAgBsB,GAAhB,CAAP;AACvB;;AAED,WAAO,IAAP;AACD;AACF","file":"format.js","sourcesContent":["import { Transform } from 'stream';\nimport stripAnsi from 'strip-ansi';\nimport { inspect } from 'util';\nimport { isEmpty } from 'ramda';\nimport Table from 'cli-table';\nimport indent from 'indent-string';\nimport { getStepLineToKeywordMap } from 'cucumber/lib/formatter/helpers/gherkin_document_parser';\nimport { getStepKeyword } from 'cucumber/lib/formatter/helpers/pickle_parser';\nimport getColorFns from 'cucumber/lib/formatter/get_color_fns';\n\nexport class StripAnsiTransform extends Transform {\n  _transform(chunk, encoding, cb) {\n    cb(null, stripAnsi(chunk.toString()));\n  }\n}\n\nconst colorFns = getColorFns(true);\nconst marker = {\n  normal: colorFns.inverse.bold,\n  warn: colorFns.yellow.inverse.bold,\n  italic: colorFns.italic,\n};\n\nexport function fence(header, obj) {\n  if (!obj || isEmpty(obj)) {\n    return `\n${marker.warn(`!  ${marker.italic(`No ${header} captured`)}  !`)}\n`;\n  } else {\n    const body = typeof obj === 'string' ? obj : inspect(obj, { colors: true, depth: null });\n\n    return `\n${marker.normal(`═════ begin ${header} ═════`)}\n${body}\n${marker.normal(`══════ end ${header} ══════`)}\n`;\n  }\n}\n\nexport function formatDataTable(arg) {\n  const rows = arg.rows\n    .map(row => row.cells\n      .map(cell => cell.value\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\n/g, '\\\\n')));\n\n  const table = new Table({\n    chars: {\n      bottom: '',\n      'bottom-left': '',\n      'bottom-mid': '',\n      'bottom-right': '',\n      left: '|',\n      'left-mid': '',\n      mid: '',\n      'mid-mid': '',\n      middle: '|',\n      right: '|',\n      'right-mid': '',\n      top: '',\n      'top-left': '',\n      'top-mid': '',\n      'top-right': '',\n    },\n    style: {\n      border: [],\n      'padding-left': 1,\n      'padding-right': 1,\n    },\n  });\n\n  table.push(...rows);\n  return `${table.toString()}\\n`;\n}\n\nexport function formatDocString(arg) {\n  return `\"\"\"\n${arg.content}\n\"\"\"\n`;\n}\n\nexport function formatScenario({ gherkinDocument, pickle }) {\n  const { bold, cyan, blue, magenta } = colorFns;\n\n  const stepLineToKeywordMap = getStepLineToKeywordMap(gherkinDocument);\n\n  let str = `${cyan(bold('Scenario:'))} ${pickle.name}\\n`;\n\n  for (const pickleStep of pickle.steps) {\n    const keyword = getStepKeyword({ pickleStep, stepLineToKeywordMap });\n\n    str += `  ${magenta(bold(keyword))}${pickleStep.text}\\n`;\n\n    const arg = stringifyArgument(pickleStep.arguments);\n    if (arg)\n      str += indent(blue(arg), 6);\n  }\n\n  return str;\n\n  function stringifyArgument([ arg ]) {\n    if (arg) {\n      if ('rows' in arg) return formatDataTable(arg);\n      if ('content' in arg) return formatDocString(arg);\n    }\n\n    return null;\n  }\n}\n"]}